# WBtech L1

### 1. **Какой самый эффективный способ конкатенации строк?**

`strings.Builder` позволяет эффективно создавать, конкатенировать строки, используя методы Write. Минимизирует копирование памяти. Не создает новые строки.

Другие методы: 

- `+`
- `strings.Join()`
- `fmt.Sprintf()`
- `bytes.Buffer`

[Benchmark](https://gist.github.com/dtjm/c6ebc86abe7515c988ec)

[strings.Builder source code](https://cs.opensource.google/go/go/+/refs/tags/go1.21.5:src/strings/builder.go)

### 2. **Что такое интерфейсы, как они применяются в Go?**

Интерфейс определяется как набор сигнатур некоторых методов. В Go интерфейсы реализуются неявно, достаточно реализовать методы интерфейса. Интерфейсы обеспечивают полиморфизм, который позволяет обрабатывать различные типы данных с помощью общих интерфейсов. 

Интерфейсы позволяют писать более структированный, универсальный и тестируемый код.

Например, чтобы удовлетворять интерфейс `Stringer`, тип должен реализовать метод `String()`.

```go
type Stringer interface {
    String() string
}
```

Еще есть пустой интерфейс - `interface{}`. Любой объект удовлетворяет пустому интерфейсу (что-то похожее на Object).

### 3. Чем отличаются RWMutex от Mutex?

`Mutex` блокирует критическую зону для всех горутин и для чтения и для записи. `RWMutex` предоставляет фунционал параллельного чтения из ресурса, но последотвальной записи в него.

RWMutex:

*При записи используется `Lock()` - `Lock` и `RLock` будут ждать разблокировки `Unlock()`*

*При чтении используется `RLock()` - `Lock` ожидает `RUnlock()`, `RLock` проходит*

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Не буферизованный канал не имеет буфера для хранения данных.

Когда в не буферизированный канал отправляется значение, горутина блокируется до тех пор, пока значение не будет прочитано в другой горутине. Горутина также блокируется и при чтении из такого канала, ожидая следующее значение. Если никто не читает или никто не отправляет данные в открытый канал - дедлок.

Буферизованный канал имеет буфер фиксированного размера.

Когда в буферизированны канал отправляется значение, горутина не блокируется до тех пор, пока буфер не будет заполнен. Когда значение из канала было прочитано - отправитель разблокируется. Потребитель блокируется, когда буфер канала пуст.

Пример использования: небуф. для синхронизации горутин, буф для обработки данных пачками.

### 5. Какой размер у структуры `struct{}{}`?

Так как структура не содержит полей - 0 байт.

Экземпляры пустой структуры имеют один и тот же адрес

Может использоваться для событий (events).

### 6. Есть ли в Go перегрузка методов или операторов?

Нет ни того, ни другого из-за “стремления в простоту” языка.

[Source](https://go.dev/doc/faq#overloading)

### 7. В какой последовательности будут выведены элементы `map[int]int`?

```go
// Пример:
m[0]=1
m[1]=124
m[2]=281
```

В хеш-таблице (`map`) порядок итерирования по элементам не определен (даже рандомизирован). Поэтому порядок вывода неизвестен.

Однако при формитаровании мапы с помощью пакета `fmt` выполняется сортировка по ключам. 

### 8. В чем разница `make` и `new`?

Обе встроенные функции используются для инициализации объектов.

`make`:

- Используется только для создания слайсов (slice), мап (map) и каналов (chan),
- Возвращает значение типа
- Выделяет память и инициализирует структуру

`new`:

- Используется для любых структур
- Возвращает указатель на значение типа
- Выделяет память, не инициализирует структуру

### 9. Сколько существует способов задать переменную типа `slice` или `map`?

```go
// 2 способа для слайса
s := []int{}

s := make([]int, params...)

// 2 способа для мапы
m := map[int]int{}

m := make(map[int]int, params...)
```

### 10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

***Вывод***: 1 1

***Почему***: по умолчанию все аргументы переделаются по значению. В функцию была передана копия указателя и изменяется значение копии.

***Исправление***: `*p = b`, вывод после исправления: 1 2

### 11. Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

***Вывод***:

0

1

2

3

4 

(или другой порядок этих чисел)

Затем дедлок.

***Почему***: в анонимную функцию переменная `wg` передана по значению, копируется, поэтому `wg.Done()` выполняется только в копии. Счетчик `wg` в главной горутине никогда не обнулится и будет блокирока на `wg.Wait()`.

***Исправление***: передать указатель на `wg`.

### 12. Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

***Вывод***: 0

***Почему***: блок if имеет свою область видимости (затенение N). При выходе из нее, объявленную там переменную N больше нельзя использовать. Поэтому выводится значение из текущей зоны видимости.

***Исправление***: `n := 1` → `n = 1`

### 13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

***Вывод***: 100 2 3 4 5

***Почему***: под капотом структура слайса содержит указатель на массив, длину, емкость. При передаче слайса в функцию эти поля копируются, поэтому можно изменить отдельный элемент, ведь указатель на массив прежний. 

Функция `append` добавляет новый элемент текущий массив, если позволяет емкость. Если емкости недостаточно, то создается новый слайс в новой области памяти.

В данном случае емкости как раз недостаточно, поэтому создается новый слайс, несвязанный с оригинальным. Даже если бы емкости хватало, длина слайса изменилась бы только в копии.

***Исправление***: возвращать новый слайс `v`

### 14. Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

***Вывод***:  [b b a][a a]

***Почему***: при передаче в анонимную функцию слайс копируется. Функция `append` создает новый слайс, так как изменилась емкость. Затем он меняется только в области видимости анонимной функции, не затрагивая оригинальный.

***Исправление***: увеличить емкость или возвращать слайс
